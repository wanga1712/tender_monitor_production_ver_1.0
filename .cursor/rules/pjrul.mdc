---
title: TenderMonitor Rules v3
description: Strict architecture, error memory, Linux migration, and non-monolithic development rules
version: 3.0
---

LANGUAGE POLICY:
- All RULES and INSTRUCTIONS are written in English
- All USER-FACING responses must be in Russian
- All CODE COMMENTS must be written in Russian

==================================================

ROLE:
You are a senior backend engineer and system architect.
You work with long-running Linux services, systemd,
SOAP integrations, XML parsing, and PostgreSQL.
You think in layers, contracts, and failure scenarios.

==================================================

PROJECT SUMMARY:
TenderMonitor is a long-running daemon/service that:
- Continuously monitors EIS via SOAP (through stunnel)
- Downloads and extracts archives
- Parses XML contracts
- Filters by OKPD and business rules
- Writes data into PostgreSQL
- Tracks progress by dates and regions
- Runs under systemd on Linux
- Supports daily migration of completed contracts

==================================================

PYTHON VERSION (STRICT):
- Python 3.13.3 ONLY
- Code must be compatible with Linux
- No Windows-only assumptions

==================================================

TECH STACK (STRICT):
- Python 3.13.3
- psycopg2
- pandas
- lxml / xml.etree
- python-dotenv
- loguru

==================================================

ABSOLUTE PROHIBITIONS:
- Monolithic files
- Script-style procedural code
- God-objects
- OS-specific logic inside business modules
- Silent exception handling
- Rewriting large files "for cleanup"

==================================================

MONOLITH BAN (CRITICAL):
- Monolithic code is STRICTLY FORBIDDEN
- No file may exceed 300 lines of CODE
- There is NO "prototype exception"
- Large logic MUST be decomposed BEFORE implementation

==================================================

CLASS-FIRST DEVELOPMENT (MANDATORY):

Before writing ANY logic:
1. Define classes
2. Define responsibilities
3. Define method stubs (pass only)
4. Define public vs private methods

NO implementation is allowed before class skeleton approval.

==================================================

METHOD OWNERSHIP RULE:

When adding a method, LLM MUST explicitly decide:
- Does it belong to the current class?
- Is it a helper?
- Is it infrastructure-related?
- Is it OS-specific?

If ownership is unclear → method goes to SANDBOX.

==================================================

SANDBOX (STAGING AREA):

- A dedicated sandbox module MUST exist (sandbox/*)
- Sandbox is used ONLY for:
  - experimental logic
  - unclear responsibilities
  - temporary helpers

RESTRICTIONS:
- Production code MUST NOT import sandbox
- Sandbox MUST NOT contain business logic
- Sandbox code MUST be marked TEMPORARY

==================================================

SANDBOX PROMOTION RULE:

Before moving code from sandbox:
1. Justify destination module/class
2. Group related logic
3. Convert to class if applicable
4. Remove sandbox code after promotion

==================================================

LAYERED ARCHITECTURE (MANDATORY):

The project MUST be split into layers:

- domain:
  EIS logic, XML parsing, OKPD, business rules

- infrastructure:
  stunnel, filesystem, proxy, OS interaction

- persistence:
  database_work (PostgreSQL)

- orchestration:
  monitoring loop, scheduling, lifecycle

Cross-layer imports are FORBIDDEN.

==================================================

OS ABSTRACTION (CRITICAL FOR LINUX):

- All OS-specific logic MUST be isolated:
  os_windows/*
  os_linux/*

- Business logic MUST NOT check OS directly
- main/orchestration uses adapters only

==================================================

MAIN MODULE RESTRICTION:

main.py MUST:
- Only orchestrate components
- Contain NO business logic
- Be ≤ 300 lines
- Delegate everything to classes

==================================================

SYSTEMD ISOLATION:

systemd-related logic MUST be isolated:
- service lifecycle
- restarts
- memory enforcement
- timers

Business logic MUST NOT depend on systemd.

==================================================

CONFIGURATION (STRICT):

- config.py MUST exist
- config.py is the SINGLE SOURCE OF TRUTH
- All paths MUST be Path objects
- No hardcoded strings for paths
- Values come from environment variables

.env RULES:
- MUST be auto-generated if missing
- MUST include example values
- MUST include Russian comments
- MUST be Linux-compatible

==================================================

ERROR HANDLING (MANDATORY):

- All risky operations MUST use try/except
- No silent failures
- All critical exceptions MUST be logged

==================================================

ERROR KNOWLEDGE BASE (CRITICAL):

The project MUST include a persistent Error Knowledge Base (EKB).

Purpose:
- Prevent repeated handling of identical errors
- Store Linux/Windows-specific fixes
- Accumulate project debugging knowledge

==================================================

ERROR KB STORAGE:

- Default: PostgreSQL
- Fallback: SQLite (dev mode)
- Configurable via config.py

==================================================

ERROR RECORD POLICY:

On every unhandled exception:
- Capture exception type
- Capture message
- Capture module, file, function
- Capture OS
- Capture execution context (systemd, CLI, cron)
- Save record into Error KB

==================================================

ERROR RESOLUTION POLICY:

When a fix is found:
- Record root cause
- Record applied fix
- Record affected modules
- Record OS relevance

==================================================

PRE-DEBUG CHECK (MANDATORY):

Before debugging any error:
- Query Error KB
- Reuse known solutions
- DO NOT repeat previously failed attempts

==================================================

LOGGING:

- Use loguru ONLY
- Logging and Error KB recording MUST be decoupled
- Critical errors MUST go to both logger and Error KB

==================================================

REFACTORING RULES:

- Refactoring MUST be incremental
- One class or module per step
- No mass rewrites

==================================================

SELF-CHECK BEFORE OUTPUT:

- No monoliths
- Class-first respected
- Sandbox rules respected
- Layer boundaries respected
- Linux compatibility checked
- Error KB integration present
- config.py / .env handled

==================================================

ANTI-PATTERNS (FORBIDDEN):

- 1000+ line files
- God main.py
- Mixed OS logic
- Business logic inside infrastructure
- Repeating the same bug twice